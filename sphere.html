<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPHERE Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        
        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        #canvas-container {
            width: 100%;
            height: 600px;
            background: radial-gradient(circle, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>The SPHERE Model</h1>
            <p>Five Rings Rotating in 3D Space</p>
        </div>
        
        <div id="canvas-container">
            <canvas id="sphereCanvas"></canvas>
        </div>
        
        <div class="controls">
            üñ±Ô∏è Drag to rotate view
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('canvas-container');
        const canvas = document.getElementById('sphereCanvas');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 10;
        
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        
        const orbitRadius = 3;
        
        // Wireframe background sphere
        const sphereGeo = new THREE.SphereGeometry(orbitRadius, 24, 24);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0x667eea, wireframe: true, transparent: true, opacity: 0.15 });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(sphere);
        
        // Ring configurations
        const configs = [
            { color: 0x3b82f6, xRot: 0.003, yRot: 0.004 },   // Blue - Confidentiality
            { color: 0x10b981, xRot: -0.004, yRot: 0.003 },  // Green - Integrity
            { color: 0xf59e0b, xRot: 0.004, yRot: -0.003 },  // Orange - Availability
            { color: 0x8b5cf6, xRot: -0.003, yRot: -0.004 }, // Purple - Authenticity
            { color: 0xef4444, xRot: 0.003, yRot: 0.004 }    // Red - Non-Repudiation
        ];
        
        const rings = [];
        
        configs.forEach((config, i) => {
            const ringGroup = new THREE.Group();
            scene.add(ringGroup);
            
            const ringGeo = new THREE.TorusGeometry(orbitRadius, 0.04, 16, 100);
            const ringMat = new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ringGroup.add(ring);
            
            const ballGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const ballMat = new THREE.MeshPhongMaterial({ color: config.color, emissive: config.color, emissiveIntensity: 0.6 });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            
            ball.position.set(orbitRadius, 0, 0);
            ring.add(ball);
            
            rings.push({ group: ringGroup, ring: ring, xRot: config.xRot, yRot: config.yRot });
        });
        
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        
        const light1 = new THREE.PointLight(0xffffff, 0.8);
        light1.position.set(10, 10, 10);
        scene.add(light1);
        
        // Interaction
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let userRot = { x: 0, y: 0 };
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                userRot.y += (e.clientX - prevMouse.x) * 0.01;
                userRot.x += (e.clientY - prevMouse.y) * 0.01;
                prevMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        window.addEventListener('mouseup', () => isDragging = false);
        
        function animate() {
            requestAnimationFrame(animate);
            
            rings.forEach(r => {
                r.group.rotation.x += r.xRot;
                r.group.rotation.y += r.yRot;
            });
            
            scene.rotation.x = userRot.x;
            scene.rotation.y = userRot.y;
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
