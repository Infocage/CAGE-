<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C.A.G.E. – Continuous Active Governance Engine</title>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #0a1628 0%, #1a1a2e 50%, #1e3a8a 100%);
    color: white;
    min-height: 100vh;
}

.hero {
    text-align: center;
    padding: 80px 20px 40px;
}

.hero h1 {
    font-size: 5em;
    letter-spacing: 10px;
    text-shadow: 0 0 30px rgba(236,72,153,0.8);
}

.hero .acronym {
    font-size: 1.8em;
    color: #ec4899;
    margin-top: 15px;
}

.hero .tagline {
    margin-top: 20px;
    font-size: 1.2em;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    opacity: 0.9;
}

#engine-wrapper {
    max-width: 1400px;
    margin: 0 auto;
    padding: 40px 20px 60px;
}

#engine-label {
    text-align: center;
    color: #ec4899;
    letter-spacing: 3px;
    margin-bottom: 15px;
}

#canvas-container {
    width: 100%;
    height: 600px;
    background: radial-gradient(circle, #1a1a2e 0%, #0a0a0a 100%);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
}

canvas {
    display: block;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 60px 20px;
}

.section {
    margin-bottom: 80px;
}

.box {
    background: rgba(236,72,153,0.1);
    border: 2px solid rgba(236,72,153,0.3);
    border-radius: 20px;
    padding: 40px;
}

.box h2 {
    color: #ec4899;
    font-size: 2.5em;
    margin-bottom: 20px;
}

.box p {
    font-size: 1.15em;
    line-height: 1.8;
    margin-bottom: 20px;
}

.diagram {
    background: rgba(10,22,40,0.9);
    border: 2px solid rgba(236,72,153,0.3);
    border-radius: 20px;
    padding: 40px;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
    color: #00ff41;
    margin-top: 30px;
}
</style>
</head>

<body>

<div class="hero">
    <h1>C.A.G.E.</h1>
    <div class="acronym">Continuous Active Governance Engine</div>
    <div class="tagline">
        A real-time governance framework integrating risk, compliance, testing, and resilience
        from board-level intent down to operational reality.
    </div>
</div>

<div id="engine-wrapper">
    <div id="engine-label">LIVE GOVERNANCE ENGINE · CONTINUOUS STATE</div>
    <div id="canvas-container">
        <canvas id="cageCanvas"></canvas>
    </div>
</div>

<div class="container">

<div class="section">
<div class="box">
<h2>Not a Replacement – An Integration Framework</h2>
<p>
CAGE does not replace ISO 27001, NIST, or existing ISMS tooling.
It acts as the governance layer that binds them together and verifies,
continuously, that governance intent is actually being executed.
</p>
<p>
Instead of discovering drift during periodic audits,
CAGE operates as a continuous verification engine,
exposing compliance, risk, and resilience in real time.
</p>
</div>
</div>

<div class="section">
<div class="diagram">
External Environment
(Threats, Regulation, OSINT, AI Drift)
              │
              ▼
┌───────────────────────────────────────────┐
│                  CAGE                     │
│   Continuous Active Governance Engine     │
│                                           │
│  Governance Intent ↔ Risk Logic ↔ Policy  │
│                                           │
│  Continuous State View                    │
│  (Compliance, Drift, Exceptions)          │
└───────────────────────────────────────────┘
        ▲               ▲               ▲
        │               │               │
     ISMS /         Operations      Auditors
     Controls        & Systems      Regulators
</div>
</div>

<div class="section">
<div class="box">
<h2>Active Testing and Resilience</h2>
<p>
Modern regulations such as NIS2 and DORA require demonstrable,
active testing of security and resilience controls.
CAGE integrates penetration testing, red teaming,
and BCP/DR exercises as governance feedback loops.
</p>
<p>
Findings are tracked until verified closed.
Failed recovery objectives immediately impact governance state
and are visible to leadership and auditors.
</p>
</div>
</div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
const container = document.getElementById('canvas-container');
const canvas = document.getElementById('cageCanvas');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.z = 7;

const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);

// Shield background
const shieldShape = new THREE.Shape();
shieldShape.moveTo(0, 2.5);
shieldShape.lineTo(-2, 1.8);
shieldShape.lineTo(-2, -0.8);
shieldShape.quadraticCurveTo(-2, -2.5, 0, -3.2);
shieldShape.quadraticCurveTo(2, -2.5, 2, -0.8);
shieldShape.lineTo(2, 1.8);
shieldShape.lineTo(0, 2.5);

const extrudeSettings = { depth: 0.8, bevelEnabled: false };
const shieldGeometry = new THREE.ExtrudeGeometry(shieldShape, extrudeSettings);

// Wireframe shield
const shieldEdges = new THREE.EdgesGeometry(shieldGeometry);
const shieldWireframe = new THREE.LineSegments(
    shieldEdges,
    new THREE.LineBasicMaterial({ color: 0x667eea, transparent: true, opacity: 0.4 })
);
shieldWireframe.position.z = -0.4;
scene.add(shieldWireframe);

// Solid shield faces
const shieldMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x667eea,
    transparent: true,
    opacity: 0.15,
    side: THREE.DoubleSide
});
const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
shield.position.z = -0.4;
scene.add(shield);

// CAGE wireframe sphere
const cageSphereGeometry = new THREE.SphereGeometry(2.8, 32, 32);
const cageSphereMaterial = new THREE.MeshBasicMaterial({
    color: 0xec4899,
    wireframe: true,
    transparent: true,
    opacity: 0.3
});
const cageSphere = new THREE.Mesh(cageSphereGeometry, cageSphereMaterial);
scene.add(cageSphere);

// Gear creation function
function createGear(radius, teeth, toothDepth) {
    const shape = new THREE.Shape();
    const angleStep = (Math.PI * 2) / teeth;
    
    for (let i = 0; i < teeth; i++) {
        const angle1 = i * angleStep;
        const angle2 = angle1 + angleStep * 0.35;
        const angle3 = angle1 + angleStep * 0.65;
        const angle4 = (i + 1) * angleStep;
        
        const innerRadius = radius;
        const outerRadius = radius + toothDepth;
        
        if (i === 0) {
            shape.moveTo(Math.cos(angle1) * innerRadius, Math.sin(angle1) * innerRadius);
        } else {
            shape.lineTo(Math.cos(angle1) * innerRadius, Math.sin(angle1) * innerRadius);
        }
        shape.lineTo(Math.cos(angle2) * outerRadius, Math.sin(angle2) * outerRadius);
        shape.lineTo(Math.cos(angle3) * outerRadius, Math.sin(angle3) * outerRadius);
        shape.lineTo(Math.cos(angle4) * innerRadius, Math.sin(angle4) * innerRadius);
    }
    shape.closePath();
    
    const holePath = new THREE.Path();
    holePath.absarc(0, 0, radius * 0.3, 0, Math.PI * 2, false);
    shape.holes.push(holePath);
    
    return shape;
}

// Three gears with magenta/pink security colors
const gearConfigs = [
    { x: 0, y: 0.5, radius: 0.55, teeth: 10, color: 0xec4899, speed: 0.02 },
    { x: -0.65, y: -0.6, radius: 0.5, teeth: 9, color: 0xf472b6, speed: -0.022 },
    { x: 0.65, y: -0.6, radius: 0.5, teeth: 9, color: 0xdb2777, speed: -0.022 }
];

const gears = [];

gearConfigs.forEach(config => {
    const gearShape = createGear(config.radius, config.teeth, 0.1);
    
    const gearExtrudeSettings = {
        depth: 0.2,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 2
    };
    
    const gearGeometry = new THREE.ExtrudeGeometry(gearShape, gearExtrudeSettings);
    const gearMaterial = new THREE.MeshPhongMaterial({ 
        color: config.color,
        emissive: config.color,
        emissiveIntensity: 0.4,
        shininess: 80
    });
    const gear = new THREE.Mesh(gearGeometry, gearMaterial);
    
    gear.position.set(config.x, config.y, 0.5);
    scene.add(gear);
    
    gears.push({ mesh: gear, speed: config.speed });
});

// Lighting
scene.add(new THREE.AmbientLight(0xffffff,0.5));

const topLight = new THREE.PointLight(0xec4899, 1.5);
topLight.position.set(0, 5, 5);
scene.add(topLight);

const bottomLight = new THREE.PointLight(0xf472b6, 1);
bottomLight.position.set(0, -3, 3);
scene.add(bottomLight);

// Animation
function animate(){
    requestAnimationFrame(animate);
    
    cageSphere.rotation.y += 0.003;
    cageSphere.rotation.x += 0.001;
    
    gears.forEach(gear => {
        gear.mesh.rotation.z += gear.speed;
    });
    
    renderer.render(scene,camera);
}
animate();

// Resize handler
window.addEventListener('resize',()=>{
    camera.aspect = container.clientWidth/container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth,container.clientHeight);
});
</script>

</body>
</html>
